---
title: "Vignette zum Paket OlfaBA"
author: "ULR"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: "/home/bachelor/Bachelor/Bibliographie/Bibliogrphie_BA_1.bib"
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
setwd("/home/bachelor/Bachelor/Paket_BHT/BTBA1")
library(tidyverse)
library(devtools)
library(pander)
```
# Das Paket BTBA1

Diese Paket soll als Langzeitalternative die Studenten im Studiengang Biotechnologie vor der Verwendung von Office-Programmen lösen.
Laden könnt ihr das Paket über:
```{r}
load_all()
```

# Grundlegendes
## Klassen und die Klassenbreite
In der Biotechnologie ist meist bekannt welcher Klasse eine Stichprobe angehört, die Klassen sind dabei die übergeordneten Gruppen welche wiederum Merkmalswerte enthalten welche in den einzelnen Stichproben wiederzufinden sind.
So als Beispiel eine Mehrfachbestimmung aus welcher dann eine Vielzahl technischer Replikate entsteht.
Bei einer Absorptionsspektroskopischen Untersuchung zum Beispiel mehrfach Messungen mit  gleichen Konzentrationen durchgeführt wobei immer Absorptionen gemessen werden, welche sich im Idealfall, kaum unterscheiden.
Die Klasse ist somit schon im Voraus klar.
Eine populäre Methode zur Berechnung der Klassenbreite $b$ ist Sturges-Regel [@doi:10.1080/01621459.1926.10502161] unter Berücksichtigung des Stichproben-Umfangs $n$ und der Spannweite $v$:
\[ b = \frac{v}{1 + 3.32 \cdot \log n } \approx \frac{v}{5 \log n} \]
oder nach Scott [@10.1093/biomet/66.3.605] unter Berücksichtigung der Standardabweichung $\sigma$ :
\[b = \frac {3{,}49 \cdot \sigma} {\sqrt[3]{n}}\]
## Mittelwert
Innerhalb einer solchen Klasse wird dann im eben beschriebenen Beispiel der Mittelwert errechnet.
In R geschieht dies über die Funktion *mean()*.
Eine Funktion kann aufgefasst werden als "Miniprogramm".
Damit dieses Miniprogramm läuft braucht es Informationen, diese bekommt es vom Anwender.
Diese Information ist, bezogen auf die Berechnung des arithmetischen Mittels, eine gewisse Anzahl von Werten, wobei für die Funktion *mean()* dabei schon alle wichtigen Information vorhanden sind, nämlich den Stichprobenumfang $n$ sowie die gemessenen Werte $x_i$:
\[\overline{n} = \frac{1}{n} \sum x_i\]
Hierzu verwenden wir die Funktion *c()*, sie fügt die einzelnen Werte zu einem Vektor zusammen.
```{r}
mean(c(1, 2, 3, 4))
# oder auch:
a <- c(1, 2.44, .56, 0.33, 1234)
mean(a)
```
**Wichtig ist zu beachten dass die Zahlen durch ein Komma getrennt werden und Nachkommastellen durch eine Punkt!**
Der Pfeil ($<-$) dient als Zeichen zur Zuordnung eines Objektes, wie unserem Vektor zu einer Variablen, unser a.
Eine Zuweisung in eine Andere Richtung ist unzulässig ($->$)
So können wir auch gleich eine Zuweisung des Mittelwert zu vornehmen:
```{r}
Mittelwert <- mean(a)
print(Mittelwert)
(Mittelwert)
```
Hier verwenden wir die Funktion *print()* um gleich den Mittelwert auf die Konsole gepromtet zu bekommen, das geschieht auch wenn wir die Variable *Mittelwert* umklammern.
So auch wenn wir eine ganze Rechenoperation umklammern:
```{r}
# Der Hashtag markiert Zeilen als Kommentar, alles was in der selben
# Zeile auf ihn folgt wird nicht mitinterpretiert
# runif verteitlt nun zehn Werte zufällig zwischen 20 und 200
(b <- runif(10, min = 20, max = 200))
(mean(b))
b <- sort(b) # Überschreiben des alten b zu einem neuen sortierten b
```
Die bisher gezeigten Funktionen gehören zu den Paketen {base} und {stats} und sind, im Gebrauch von R.Studio immer vorhanden, anders als Pakete welche explizit geladen werden müssen.
Auch zugänglich ist immer das Paket {graphics}:
```{r}
c <- runif(2222, 22, 100) # min und max kann man auch weglassen, ;-)
boxplot(b, c) # Ein einfacher Boxplot aus den Objekten a und b
hist(c) # Histogramm
nclass.Sturges(c) # Berechnung der Klassenbreite nach Sturges
nclass.scott(c) # Berechnung der Klassenbreite nach Scott
hist(c, 
     nclass = 13, # Wählen der Klassenbreite
     main = "Klassenbreite = 13" # einfügen einer Überschrift
     ) 
```
Das Paket {graphics} enthält eine umfassenden Sammlung an einfachen Plottingfunktionen, wer sich dafür interessiert ist unter https://www.rdocumentation.org/packages/graphics/versions/3.6.2 an der richtigen Stelle.

## Steuerungsparameter

Um beurteilen zu können ob ein Experiment Informationen liefert, die im Kontext zur Durchführung sinnvoll scheinen, können wir untersuchen wie die einzelnen Messwerte mit einander korrelieren.
Im Fall einer vierfach-Bestimmung ist das einfach nachvollziehbar:
```{r}
mean( c(1,2,3,4) )
mean( c(2,2.5,3,2.5))
```
Die technischen Replikate der ersten Messung liegen weit auseinander aber haben das selbe arithmetische Mittel wie die der zweiten Messung welche aber doch recht ähnliche Ergebnisse liefert!

Um einen Wert für die Abweichung der Messpunkte einer Messung zu einander zu können wir die  Summe der Abweichungsquadrate $SQ$ ermitteln:
\[SQ:=\sum\limits_{i=1}^n (x_i - \overline x)^2=(n-1) s_x^2\]
Wobei nun immer nur ein einzelner Punkt betrachtet wird, für die Messung selbst ist die Varianz $s_x^2$ von Interesse, sie beschreibt die Summe aller $SQ$:
\[s_{x}^{2}=\frac{1}{n-1} \sum \limits_{i=1}^n\left(x_i-\overline x\right)^2\]
Die dazugehörige Funktion in R heißt *var()*:
```{r}
var( c(1, 2, 3, 4))
var( c(2,2.5,3,2.5))
var( rep(2.5, 4)) # rep() lässt einen Vektor aus vier mal 2,5 entstehen!
```
Die Standardabweichung $s = \sqrt{s_x^2}$ wiederum ist die positive Wurzel der Varianz und bekommt die den Namen *sd()*:
```{r}
sqrt(var(c(1, 2, 3, 4))) # sqrt() ist die Quadratwurzel
var(c(1, 2, 3, 4)) ^ (1/2) # Wobei es auch so geht
sd( c(1, 2, 3, 4))
sd( c(2,2.5,3,2.5))
sd( rep(2.5, 4))
```
> R eignet sich im Labor super als Taschenrechner-Ersatz, Alle mathematischen Funktionen sind vorhanden, die Rechnungen können auch leicht modifiziert werden und wenn man sie als Skript schreibt kann super nachvollzogen werden was gerechnet wurde!
Dies hilft auch sich an die Sprache R zu gewöhnen, sollte aber kein allzu aufwendiger Prozess werden :-) (Ich hab's ja auch geschafft)

Möchten wir etwas mehr über unseren Mittelwert erfahren dividieren wir die Standard-Abweichung $s$ durch die Wurzel des Stichprobenumfang, also den Standardfehler $s_{\bar{x}}=\frac{s}{\sqrt{n}}$.
Wir haben nun alle Werkzeuge um die Funktion für den Standardfehler selbst zu definieren.
Dazu verwenden wir den Befehl *function()*:
```{r}
sde <- function(x) { # die Runde Klammer definiert das Argument der Funktion
  # Die geschweifte Klammer enthält die Definition der Funktion
  sd(x)/
    sqrt(length(x)) # length() ist die länge des Vektors von x
}
sde(c(1, 2, 3, 4))
sde(c(2,2.5,3,2.5))
sde(rep(2.5, 4))
```

